/**
 * Shared type definitions for pipeline steps
 */

import type OpenAI from "openai";

/**
 * Base class for all clustering errors
 */
export class ClusteringError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "ClusteringError";
  }
}

/**
 * Error thrown when the API call fails
 */
export class ApiCallFailedError extends ClusteringError {
  constructor(
    public modelName: string,
    public reason: string,
  ) {
    super(`API call failed for model ${modelName}: ${reason}`);
    this.name = "ApiCallFailedError";
  }
}

/**
 * Error thrown when the API returns no content
 */
export class EmptyResponseError extends ClusteringError {
  constructor(public modelName: string) {
    super(`No response from clustering model: ${modelName}`);
    this.name = "EmptyResponseError";
  }
}

/**
 * Error thrown when JSON parsing fails
 */
export class ParseFailedError extends ClusteringError {
  constructor(
    public content: string,
    public reason: string,
  ) {
    super(`Failed to parse clustering response: ${reason}`);
    this.name = "ParseFailedError";
  }
}

/**
 * A single comment from a user
 * @property id - Unique identifier for the comment
 * @property text - The comment text content
 * @property speaker - Name or identifier of the person who made the comment
 * @property interview - Optional interview identifier or context
 */
export interface Comment {
  id: string;
  text: string;
  speaker: string;
  interview?: string;
}

/**
 * Configuration for LLM API calls
 * @property model_name - Name of the OpenAI model to use (e.g., "gpt-4o-mini")
 * @property system_prompt - System-level instructions for the LLM
 * @property user_prompt - User-level prompt template
 */
export interface LLMConfig {
  model_name: string;
  system_prompt: string;
  user_prompt: string;
}

/**
 * A subtopic within a larger topic
 * @property subtopicName - Concise name of the subtopic
 * @property subtopicShortDescription - Brief description of the subtopic (70-90 words)
 */
export interface Subtopic {
  subtopicName: string;
  subtopicShortDescription: string;
}

/**
 * A topic containing related subtopics
 * @property topicName - Concise name of the topic
 * @property topicShortDescription - Brief description of the topic (25-35 words)
 * @property subtopics - Array of related subtopics
 */
export interface Topic {
  topicName: string;
  topicShortDescription: string;
  subtopics: Subtopic[];
}

/**
 * A taxonomy structure containing topics
 * @property taxonomy - Array of topics
 */
export interface Taxonomy {
  taxonomy: Topic[];
}

/**
 * Token usage statistics from an LLM API call
 * @property prompt_tokens - Number of tokens in the input prompt
 * @property completion_tokens - Number of tokens in the model's response
 * @property total_tokens - Total tokens used (prompt + completion)
 */
export interface TokenUsage {
  input_tokens: number;
  output_tokens: number;
  total_tokens: number;
}

/**
 * Result from topic tree generation
 * @property data - Array of generated topics with subtopics
 * @property usage - Token usage statistics
 * @property cost - Estimated cost in USD
 */
export interface TopicTreeResult {
  data: Topic[];
  usage: TokenUsage;
  cost: number;
}

/**
 * Options for clustering operations
 * @property reportId - Optional identifier for the report being processed
 * @property userId - Optional identifier for the user making the request
 * @property enableWandB - Optional flag to enable Weights & Biases logging
 * @property enableWeave - Optional flag to enable Weave evaluation tracking
 * @property weaveProjectName - Optional Weave project name for tracking
 */
export interface ClusteringOptions {
  reportId?: string;
  userId?: string;
  enableWandB?: boolean;
  enableWeave?: boolean;
  weaveProjectName?: string;
}

/**
 * Input for clustering model evaluation
 * @property comments - Raw comments text to be clustered
 */
export interface ClusteringInput {
  comments: string;
}

/**
 * Output from clustering model with usage tracking
 * @property taxonomy - Array of topics generated by the clustering model
 * @property usage - Token usage statistics from the API call
 * @property cost - Estimated cost in USD for the API call
 */
export interface ClusteringOutput {
  taxonomy: Topic[];
  usage: TokenUsage;
  cost: number;
}

/**
 * A claim extracted from user comments
 * @property claim - The normalized claim statement
 * @property quote - Original quote from the comment
 * @property speaker - Name or identifier of the person who made the comment
 * @property topicName - The topic this claim belongs to
 * @property subtopicName - The subtopic this claim belongs to
 * @property commentId - ID of the original comment
 */
export interface Claim {
  claim: string;
  quote: string;
  speaker: string;
  topicName: string;
  subtopicName: string;
  commentId: string;
}

/**
 * A deduplicated claim with duplicates and duplicated fields
 * After deduplication, all claims have these fields populated
 */
export interface DedupedClaim extends Claim {
  duplicates: DedupedClaim[];
  duplicated: boolean;
}

/**
 * Claims grouped under a subtopic
 * @property total - Total number of claims in this subtopic
 * @property claims - Array of claims in this subtopic
 */
export interface SubtopicClaimNode {
  total: number;
  claims: Claim[];
}

/**
 * Subtopics with their claims, grouped under a topic
 * @property total - Total number of claims in this topic across all subtopics
 * @property subtopics - Record mapping subtopic names to their claim nodes
 */
export interface TopicClaimNode {
  total: number;
  subtopics: Record<string, SubtopicClaimNode>;
}

/**
 * The complete claims tree structure
 * Maps topic names to their claim nodes
 */
export type ClaimsTree = Record<string, TopicClaimNode>;

/**
 * Grouped claim from LLM deduplication response
 * @property claimText - The consolidated/grouped claim text
 * @property originalClaimIds - Array of original claim IDs that were grouped (e.g., ["claimId0", "claimId1"])
 */
export interface GroupedClaim {
  claimText: string;
  originalClaimIds: (string | number)[];
}

/**
 * Deduplication response from LLM
 * @property groupedClaims - Array of grouped claims with their original IDs
 */
export interface DeduplicationResponse {
  groupedClaims: GroupedClaim[];
}

/**
 * Subtopic with deduped claims (output format)
 * @property claims - Array of deduplicated and sorted claims
 * @property speakers - Array of unique speakers in this subtopic
 * @property counts - Counts of claims and speakers
 */
export interface ProcessedSubtopic {
  claims: DedupedClaim[];
  speakers: string[];
  counts: {
    claims: number;
    speakers: number;
  };
}

/**
 * Topic with processed subtopics (output format)
 * @property topics - Array of [subtopicName, subtopicData] tuples, sorted by frequency
 * @property speakers - Array of unique speakers in this topic
 * @property counts - Counts of claims and speakers
 */
export interface ProcessedTopic {
  topics: [string, ProcessedSubtopic][];
  speakers: string[];
  counts: {
    claims: number;
    speakers: number;
  };
}

/**
 * Sorted tree structure (output format)
 * Array of [topicName, topicData] tuples, sorted by frequency
 */
export type SortedTree = [string, ProcessedTopic][];

/**
 * Sorting strategy for topics, subtopics, and claims
 */
export type SortStrategy = "numPeople" | "numClaims";

/**
 * Input configuration for sort and deduplicate step
 * @property tree - The claims tree to process
 * @property llm - LLM configuration for deduplication
 * @property sort - Sorting strategy (by number of people or number of claims)
 */
export interface SortAndDeduplicateInput {
  tree: ClaimsTree;
  llm: LLMConfig;
  sort: SortStrategy;
}

/**
 * Result from sort and deduplicate step
 * @property data - The sorted and deduplicated tree
 * @property usage - Token usage statistics
 * @property cost - Estimated cost in USD
 */
export interface SortAndDeduplicateResult {
  data: SortedTree;
  usage: TokenUsage;
  cost: number;
}

/**
 * Output from deduplication model with usage tracking
 * @property dedupClaims - Deduplication response with grouped claims
 * @property usage - Token usage statistics from the API call
 */
export interface DeduplicationOutput {
  dedupClaims: DeduplicationResponse;
  usage: TokenUsage;
}

/**
 * Return type for processSubtopic function
 * @property claims - Processed and sorted deduplicated claims
 * @property speakers - Set of unique speakers in the subtopic
 * @property usage - Token usage statistics
 */
export interface ProcessSubtopicResult {
  claims: DedupedClaim[];
  speakers: Set<string>;
  usage: TokenUsage;
}

/**
 * Result from claims extraction
 * @property data - The claims tree with all extracted claims organized by topic/subtopic
 * @property usage - Token usage statistics from the LLM calls
 * @property cost - Estimated total cost in USD
 */
export interface ClaimsResult {
  data: ClaimsTree;
  usage: TokenUsage;
  cost: number;
}

/**
 * Options for claims extraction
 * @property reportId - Optional identifier for the report being processed
 * @property userId - Optional identifier for the user making the request
 * @property enableScoring - Optional flag to enable evaluation scoring
 */
export interface ClaimsOptions {
  reportId?: string;
  userId?: string;
  enableScoring?: boolean;
}

/**
 * Output from claims extraction model
 * @property claims - Array of claims with topic/subtopic assignments (without speaker/commentId)
 */
export interface ClaimsOutput {
  claims: Array<{
    claim: string;
    quote: string;
    topicName: string;
    subtopicName: string;
  }>;
}

/**
 * Full result from claims extraction model including usage and cost
 * @property claims - Array of extracted claims with all metadata
 * @property usage - Token usage statistics from the API call
 * @property cost - Estimated cost in USD for the API call
 */
export interface ClaimsModelResult {
  claims: Claim[];
  usage: TokenUsage;
  cost: number;
}

/**
 * Input parameters for claims extraction from a single comment
 */
export interface ExtractClaimsInput {
  /** OpenAI client instance */
  openaiClient: OpenAI;
  /** Model name (e.g., "gpt-4o-mini") */
  modelName: string;
  /** System prompt */
  systemPrompt: string;
  /** User prompt template */
  userPrompt: string;
  /** The comment text to extract claims from */
  commentText: string;
  /** Array of topics with subtopics */
  taxonomy: Topic[];
  /** The speaker who made the comment */
  speaker: string;
  /** The ID of the comment */
  commentId: string;
  /** Optional evaluation options */
  options?: {
    enableScoring?: boolean;
    weaveProjectName?: string;
  };
}

/**
 * A topic summary containing the topic name and summary text
 * @property topicName - Name of the topic
 * @property summary - Summary text for the topic
 */
export interface TopicSummary {
  topicName: string;
  summary: string;
}

/**
 * Input configuration for generating topic summaries
 * @property tree - The sorted and deduplicated tree structure
 * @property llm - LLM configuration for summary generation
 */
export interface SummariesInput {
  tree: SortedTree;
  llm: LLMConfig;
}

/**
 * Result from topic summaries pipeline step
 * @property data - Array of topic summaries
 * @property usage - Token usage statistics
 * @property cost - Estimated cost in USD
 */
export interface SummariesResult {
  data: TopicSummary[];
  usage: TokenUsage;
  cost: number;
}

/**
 * Result from summary generation model including usage and cost
 * @property summary - The generated summary text
 * @property usage - Token usage statistics from the API call
 * @property cost - Estimated cost in USD for the API call
 */
export interface SummaryModelResult {
  summary: string;
  usage: TokenUsage;
  cost: number;
}

/**
 * Input parameters for generating a summary for a single topic
 */
export interface GenerateSummaryInput {
  /** OpenAI client instance */
  openaiClient: OpenAI;
  /** Model name (e.g., "gpt-4o-mini") */
  modelName: string;
  /** System prompt */
  systemPrompt: string;
  /** User prompt template */
  userPrompt: string;
  /** The tree data for a single topic */
  tree: SortedTree;
  /** The topic name */
  topicName: string;
  /** Optional report ID for logging context */
  reportId?: string;
  /** Optional Weave evaluation options */
  options?: {
    enableWeave?: boolean;
    weaveProjectName?: string;
  };
}

/**
 * A crux claim for a specific subtopic with speaker positions
 * @property topic - The topic name this crux belongs to
 * @property subtopic - The subtopic name this crux belongs to
 * @property cruxClaim - The crux claim statement that splits opinions
 * @property agree - Array of speakers who agree with the crux (format: "id:name")
 * @property disagree - Array of speakers who disagree with the crux (format: "id:name")
 * @property no_clear_position - Array of speakers with no clear position (format: "id:name")
 * @property explanation - Explanation of the crux and positions
 * @property agreementScore - Ratio of speakers who agree (0-1)
 * @property disagreementScore - Ratio of speakers who disagree (0-1)
 * @property controversyScore - How evenly split opinions are (0-1, higher = more split)
 * @property speakersInvolved - Number of speakers who took a position (agree/disagree)
 * @property totalSpeakersInSubtopic - Total number of speakers in this subtopic
 */
export interface SubtopicCrux {
  topic: string;
  subtopic: string;
  cruxClaim: string;
  agree: string[];
  disagree: string[];
  no_clear_position: string[];
  explanation: string;
  agreementScore: number;
  disagreementScore: number;
  controversyScore: number;
  speakersInvolved: number;
  totalSpeakersInSubtopic: number;
}

/**
 * Topic-level rollup scores
 * @property topic - The topic name
 * @property averageControversy - Average controversy across all subtopics
 * @property subtopicCount - Number of subtopics in this topic
 * @property totalSpeakers - Total number of unique speakers across all subtopics
 */
export interface TopicScore {
  topic: string;
  averageControversy: number;
  subtopicCount: number;
  totalSpeakers: number;
}

/**
 * Speaker × Crux agreement matrix for visualization
 * @property speakers - Array of all speaker IDs (format: "id:name")
 * @property cruxLabels - Array of crux labels (format: "Topic → Subtopic")
 * @property matrix - 2D array where matrix[speakerIdx][cruxIdx] is "agree", "disagree", or "no_position"
 */
export interface SpeakerCruxMatrix {
  speakers: string[];
  cruxLabels: string[];
  matrix: string[][];
}

/**
 * Raw crux response from LLM (before validation)
 * @property cruxClaim - The crux claim statement
 * @property agree - Array of speaker IDs who agree (may be in "ID:claim" format)
 * @property disagree - Array of speaker IDs who disagree (may be in "ID:claim" format)
 * @property no_clear_position - Array of speaker IDs with no clear position (may be in "ID:claim" format)
 * @property explanation - Explanation of the crux
 */
export interface RawCruxResponse {
  crux: {
    cruxClaim: string;
    agree: (string | number)[];
    disagree: (string | number)[];
    no_clear_position?: (string | number)[];
    explanation?: string;
  };
}

/**
 * Result from cruxes extraction
 * @property subtopicCruxes - Array of crux objects for each subtopic
 * @property topicScores - Array of topic-level rollup scores
 * @property speakerCruxMatrix - Speaker × Crux agreement matrix
 * @property usage - Token usage statistics from the LLM calls
 * @property cost - Estimated total cost in USD
 */
export interface CruxesResult {
  subtopicCruxes: SubtopicCrux[];
  topicScores: TopicScore[];
  speakerCruxMatrix: SpeakerCruxMatrix;
  usage: TokenUsage;
  cost: number;
}

/**
 * Options for cruxes extraction
 * @property reportId - Optional identifier for the report being processed
 * @property userId - Optional identifier for the user making the request
 * @property enableWeave - Optional flag to enable Weave evaluation tracking
 * @property weaveProjectName - Optional Weave project name for tracking
 */
export interface CruxesOptions {
  reportId?: string;
  userId?: string;
  enableWeave?: boolean;
  weaveProjectName?: string;
}

/**
 * Result from single subtopic crux extraction
 * @property crux - The raw crux response from LLM
 * @property usage - Token usage for this API call
 */
export interface CruxForTopicResult {
  crux: RawCruxResponse;
  usage: {
    total_tokens: number;
    input_tokens: number;
    output_tokens: number;
  };
}

/**
 * Speaker map type - maps speaker names to numeric IDs
 */
export type SpeakerMap = Record<string, string>;

/**
 * Topic description map - maps topic/subtopic names to descriptions
 */
export type TopicDescMap = Record<string, string>;

/**
 * Input parameters for generating a crux for a single subtopic
 */
export interface GenerateCruxInput {
  /** OpenAI client instance */
  openaiClient: OpenAI;
  /** Model name (e.g., "gpt-4o-mini") */
  modelName: string;
  /** System prompt */
  systemPrompt: string;
  /** User prompt template */
  userPrompt: string;
  /** Topic identifier (format: "Topic, Subtopic") */
  topic: string;
  /** Description of the subtopic */
  topicDesc: string;
  /** Array of claims for this subtopic */
  claims: Claim[];
  /** Speaker map (name -> numeric ID) */
  speakerMap: SpeakerMap;
  /** Index of this subtopic for logging */
  subtopicIndex: number;
  /** Optional report ID for logging context */
  reportId?: string;
  /** Optional Weave evaluation options */
  options?: {
    enableWeave?: boolean;
    weaveProjectName?: string;
  };
}
/**
 * Subtopic item to process during crux extraction
 */
export interface SubtopicItem {
  topicName: string;
  subtopicName: string;
  claims: Claim[];
  subtopicDesc: string;
  cruxIdentifier: string;
  subtopicIndex: number;
  totalSpeakersInSubtopic: number;
}

/**
 * Parameters for crux evaluation
 */
export interface CruxEvaluationParams {
  openaiClient: OpenAI;
  cruxResponse: RawCruxResponse;
  claims: string[];
  totalSpeakers: number;
  topic: string;
}

/**
 * Validated speaker IDs extracted from LLM response
 */
export interface ValidatedSpeakerIds {
  agreeIds: string[];
  disagreeIds: string[];
  noClearPositionIds: string[];
}

/**
 * Context for validating speaker IDs
 */
export interface SpeakerValidationContext {
  validIds: Set<string>;
  cruxIdentifier: string;
  reportLogger: import("pino").Logger;
}

/**
 * Context for processing subtopic results
 */
export interface SubtopicProcessingContext {
  idsToSpeakers: Record<string, string>;
  validIds: Set<string>;
  reportLogger: import("pino").Logger;
}

/**
 * Anonymized claims with speaker IDs
 */
export interface AnonymizedClaims {
  claimsAnon: string[];
  speakerCount: number;
}

/**
 * Sanitized topic information
 */
export interface SanitizedTopicInfo {
  sanitizedTopic: string;
  sanitizedTopicDesc: string;
}

/**
 * Input parameters for cruxes extraction
 */
export interface ExtractCruxesInput {
  /** Claims tree organized by topic → subtopic → claims */
  claimsTree: ClaimsTree;
  /** Array of topics with descriptions (from clustering step) */
  topics: Topic[];
  /** LLM configuration (model, prompts) */
  llmConfig: LLMConfig;
  /** OpenAI API key */
  apiKey: string;
  /** Optional configuration */
  options?: CruxesOptions;
}
