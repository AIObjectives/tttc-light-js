/**
 * Shared type definitions for pipeline steps
 */

import type OpenAI from "openai";

/**
 * Base class for all clustering errors
 */
export class ClusteringError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "ClusteringError";
  }
}

/**
 * Error thrown when the API call fails
 */
export class ApiCallFailedError extends ClusteringError {
  constructor(
    public modelName: string,
    public reason: string,
  ) {
    super(`API call failed for model ${modelName}: ${reason}`);
    this.name = "ApiCallFailedError";
  }
}

/**
 * Error thrown when the API returns no content
 */
export class EmptyResponseError extends ClusteringError {
  constructor(public modelName: string) {
    super(`No response from clustering model: ${modelName}`);
    this.name = "EmptyResponseError";
  }
}

/**
 * Error thrown when JSON parsing fails
 */
export class ParseFailedError extends ClusteringError {
  constructor(
    public content: string,
    public reason: string,
  ) {
    super(`Failed to parse clustering response: ${reason}`);
    this.name = "ParseFailedError";
  }
}

/**
 * A single comment from a user
 * @property id - Unique identifier for the comment
 * @property text - The comment text content
 * @property speaker - Name or identifier of the person who made the comment
 * @property interview - Optional interview identifier or context
 */
export interface Comment {
  id: string;
  text: string;
  speaker: string;
  interview?: string;
}

/**
 * Configuration for LLM API calls
 * @property model_name - Name of the OpenAI model to use (e.g., "gpt-4o-mini")
 * @property system_prompt - System-level instructions for the LLM
 * @property user_prompt - User-level prompt template
 */
export interface LLMConfig {
  model_name: string;
  system_prompt: string;
  user_prompt: string;
}

/**
 * A subtopic within a larger topic
 * @property subtopicName - Concise name of the subtopic
 * @property subtopicShortDescription - Brief description of the subtopic (70-90 words)
 */
export interface Subtopic {
  subtopicName: string;
  subtopicShortDescription: string;
}

/**
 * A topic containing related subtopics
 * @property topicName - Concise name of the topic
 * @property topicShortDescription - Brief description of the topic (25-35 words)
 * @property subtopics - Array of related subtopics
 */
export interface Topic {
  topicName: string;
  topicShortDescription: string;
  subtopics: Subtopic[];
}

/**
 * A taxonomy structure containing topics
 * @property taxonomy - Array of topics
 */
export interface Taxonomy {
  taxonomy: Topic[];
}

/**
 * Token usage statistics from an LLM API call
 * @property prompt_tokens - Number of tokens in the input prompt
 * @property completion_tokens - Number of tokens in the model's response
 * @property total_tokens - Total tokens used (prompt + completion)
 */
export interface TokenUsage {
  input_tokens: number;
  output_tokens: number;
  total_tokens: number;
}

/**
 * Result from topic tree generation
 * @property data - Array of generated topics with subtopics
 * @property usage - Token usage statistics
 * @property cost - Estimated cost in USD
 */
export interface TopicTreeResult {
  data: Topic[];
  usage: TokenUsage;
  cost: number;
}

/**
 * Options for clustering operations
 * @property reportId - Optional identifier for the report being processed
 * @property userId - Optional identifier for the user making the request
 * @property enableWandB - Optional flag to enable Weights & Biases logging
 * @property enableWeave - Optional flag to enable Weave evaluation tracking
 * @property weaveProjectName - Optional Weave project name for tracking
 */
export interface ClusteringOptions {
  reportId?: string;
  userId?: string;
  enableWandB?: boolean;
  enableWeave?: boolean;
  weaveProjectName?: string;
}

/**
 * Input for clustering model evaluation
 * @property comments - Raw comments text to be clustered
 */
export interface ClusteringInput {
  comments: string;
}

/**
 * Output from clustering model with usage tracking
 * @property taxonomy - Array of topics generated by the clustering model
 * @property usage - Token usage statistics from the API call
 * @property cost - Estimated cost in USD for the API call
 */
export interface ClusteringOutput {
  taxonomy: Topic[];
  usage: TokenUsage;
  cost: number;
}

/**
 * A claim extracted from user comments
 * @property claim - The normalized claim statement
 * @property quote - Original quote from the comment
 * @property speaker - Name or identifier of the person who made the comment
 * @property topicName - The topic this claim belongs to
 * @property subtopicName - The subtopic this claim belongs to
 * @property commentId - ID of the original comment
 */
export interface Claim {
  claim: string;
  quote: string;
  speaker: string;
  topicName: string;
  subtopicName: string;
  commentId: string;
}

/**
 * A deduplicated claim with duplicates and duplicated fields
 * After deduplication, all claims have these fields populated
 */
export interface DedupedClaim extends Claim {
  duplicates: DedupedClaim[];
  duplicated: boolean;
}

/**
 * Claims grouped under a subtopic
 * @property total - Total number of claims in this subtopic
 * @property claims - Array of claims in this subtopic
 */
export interface SubtopicClaimNode {
  total: number;
  claims: Claim[];
}

/**
 * Subtopics with their claims, grouped under a topic
 * @property total - Total number of claims in this topic across all subtopics
 * @property subtopics - Record mapping subtopic names to their claim nodes
 */
export interface TopicClaimNode {
  total: number;
  subtopics: Record<string, SubtopicClaimNode>;
}

/**
 * The complete claims tree structure
 * Maps topic names to their claim nodes
 */
export type ClaimsTree = Record<string, TopicClaimNode>;

/**
 * Grouped claim from LLM deduplication response
 * @property claimText - The consolidated/grouped claim text
 * @property originalClaimIds - Array of original claim IDs that were grouped (e.g., ["claimId0", "claimId1"])
 */
export interface GroupedClaim {
  claimText: string;
  originalClaimIds: (string | number)[];
}

/**
 * Deduplication response from LLM
 * @property groupedClaims - Array of grouped claims with their original IDs
 */
export interface DeduplicationResponse {
  groupedClaims: GroupedClaim[];
}

/**
 * Subtopic with deduped claims (output format)
 * @property claims - Array of deduplicated and sorted claims
 * @property speakers - Array of unique speakers in this subtopic
 * @property counts - Counts of claims and speakers
 */
export interface ProcessedSubtopic {
  claims: DedupedClaim[];
  speakers: string[];
  counts: {
    claims: number;
    speakers: number;
  };
}

/**
 * Topic with processed subtopics (output format)
 * @property topics - Array of [subtopicName, subtopicData] tuples, sorted by frequency
 * @property speakers - Array of unique speakers in this topic
 * @property counts - Counts of claims and speakers
 */
export interface ProcessedTopic {
  topics: [string, ProcessedSubtopic][];
  speakers: string[];
  counts: {
    claims: number;
    speakers: number;
  };
}

/**
 * Sorted tree structure (output format)
 * Array of [topicName, topicData] tuples, sorted by frequency
 */
export type SortedTree = [string, ProcessedTopic][];

/**
 * Sorting strategy for topics, subtopics, and claims
 */
export type SortStrategy = "numPeople" | "numClaims";

/**
 * Input configuration for sort and deduplicate step
 * @property tree - The claims tree to process
 * @property llm - LLM configuration for deduplication
 * @property sort - Sorting strategy (by number of people or number of claims)
 */
export interface SortAndDeduplicateInput {
  tree: ClaimsTree;
  llm: LLMConfig;
  sort: SortStrategy;
}

/**
 * Result from sort and deduplicate step
 * @property data - The sorted and deduplicated tree
 * @property usage - Token usage statistics
 * @property cost - Estimated cost in USD
 */
export interface SortAndDeduplicateResult {
  data: SortedTree;
  usage: TokenUsage;
  cost: number;
}

/**
 * Output from deduplication model with usage tracking
 * @property dedupClaims - Deduplication response with grouped claims
 * @property usage - Token usage statistics from the API call
 */
export interface DeduplicationOutput {
  dedupClaims: DeduplicationResponse;
  usage: TokenUsage;
}

/**
 * Return type for processSubtopic function
 * @property claims - Processed and sorted deduplicated claims
 * @property speakers - Set of unique speakers in the subtopic
 * @property usage - Token usage statistics
 */
export interface ProcessSubtopicResult {
  claims: DedupedClaim[];
  speakers: Set<string>;
  usage: TokenUsage;
}

/**
 * Result from claims extraction
 * @property data - The claims tree with all extracted claims organized by topic/subtopic
 * @property usage - Token usage statistics from the LLM calls
 * @property cost - Estimated total cost in USD
 */
export interface ClaimsResult {
  data: ClaimsTree;
  usage: TokenUsage;
  cost: number;
}

/**
 * Options for claims extraction
 * @property reportId - Optional identifier for the report being processed
 * @property userId - Optional identifier for the user making the request
 * @property enableScoring - Optional flag to enable evaluation scoring
 */
export interface ClaimsOptions {
  reportId?: string;
  userId?: string;
  enableScoring?: boolean;
}

/**
 * Output from claims extraction model
 * @property claims - Array of claims with topic/subtopic assignments (without speaker/commentId)
 */
export interface ClaimsOutput {
  claims: Array<{
    claim: string;
    quote: string;
    topicName: string;
    subtopicName: string;
  }>;
}

/**
 * Full result from claims extraction model including usage and cost
 * @property claims - Array of extracted claims with all metadata
 * @property usage - Token usage statistics from the API call
 * @property cost - Estimated cost in USD for the API call
 */
export interface ClaimsModelResult {
  claims: Claim[];
  usage: TokenUsage;
  cost: number;
}

/**
 * Input parameters for claims extraction from a single comment
 */
export interface ExtractClaimsInput {
  /** OpenAI client instance */
  openaiClient: OpenAI;
  /** Model name (e.g., "gpt-4o-mini") */
  modelName: string;
  /** System prompt */
  systemPrompt: string;
  /** User prompt template */
  userPrompt: string;
  /** The comment text to extract claims from */
  commentText: string;
  /** Array of topics with subtopics */
  taxonomy: Topic[];
  /** The speaker who made the comment */
  speaker: string;
  /** The ID of the comment */
  commentId: string;
  /** Optional evaluation options */
  options?: {
    enableScoring?: boolean;
    weaveProjectName?: string;
  };
}

/**
 * A topic summary containing the topic name and summary text
 * @property topicName - Name of the topic
 * @property summary - Summary text for the topic
 */
export interface TopicSummary {
  topicName: string;
  summary: string;
}

/**
 * Input configuration for generating topic summaries
 * @property tree - The sorted and deduplicated tree structure
 * @property llm - LLM configuration for summary generation
 */
export interface SummariesInput {
  tree: SortedTree;
  llm: LLMConfig;
}

/**
 * Result from topic summaries pipeline step
 * @property data - Array of topic summaries
 * @property usage - Token usage statistics
 * @property cost - Estimated cost in USD
 */
export interface SummariesResult {
  data: TopicSummary[];
  usage: TokenUsage;
  cost: number;
}

/**
 * Result from summary generation model including usage and cost
 * @property summary - The generated summary text
 * @property usage - Token usage statistics from the API call
 * @property cost - Estimated cost in USD for the API call
 */
export interface SummaryModelResult {
  summary: string;
  usage: TokenUsage;
  cost: number;
}

/**
 * Input parameters for generating a summary for a single topic
 */
export interface GenerateSummaryInput {
  /** OpenAI client instance */
  openaiClient: OpenAI;
  /** Model name (e.g., "gpt-4o-mini") */
  modelName: string;
  /** System prompt */
  systemPrompt: string;
  /** User prompt template */
  userPrompt: string;
  /** The tree data for a single topic */
  tree: SortedTree;
  /** The topic name */
  topicName: string;
  /** Optional report ID for logging context */
  reportId?: string;
  /** Optional Weave evaluation options */
  options?: {
    enableWeave?: boolean;
    weaveProjectName?: string;
  };
}
